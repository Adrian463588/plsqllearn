import { MCQuestion, CodeChallenge } from '@/types';

export const cat05MCQ: MCQuestion[] = [
  { id: 'MCQ_077', category: 'exception-handling', difficulty: 'Easy', type: 'multiple_choice', question: 'Apa yang terjadi jika exception tidak di-handle di PL/SQL?', options: ['Program berjalan terus', 'Exception diabaikan', 'Program berhenti dan error ditampilkan ke client', 'Oracle otomatis retry'], correctAnswer: 2, explanation: 'Jika exception tidak di-handle, program berhenti dan unhandled exception di-propagate ke calling environment, menampilkan error message.', tags: ['unhandled', 'propagation'] },
  { id: 'MCQ_078', category: 'exception-handling', difficulty: 'Easy', type: 'multiple_choice', question: 'Exception mana yang di-raise ketika SELECT INTO tidak return data?', options: ['ZERO_DIVIDE', 'TOO_MANY_ROWS', 'NO_DATA_FOUND', 'VALUE_ERROR'], correctAnswer: 2, explanation: 'NO_DATA_FOUND di-raise ketika SELECT INTO tidak menemukan baris. Jika menemukan lebih dari satu baris, TOO_MANY_ROWS di-raise.', tags: ['no_data_found', 'select-into'] },
  { id: 'MCQ_079', category: 'exception-handling', difficulty: 'Medium', type: 'multiple_choice', question: 'Bagaimana cara membuat user-defined exception?', options: ['exc EXCEPTION; lalu RAISE exc;', 'THROW NEW Exception()', 'CREATE EXCEPTION exc;', 'DEFINE EXCEPTION exc ON ERROR'], correctAnswer: 0, explanation: 'User-defined exception: 1) Deklarasi: exc EXCEPTION; 2) Raise: RAISE exc; 3) Handle: WHEN exc THEN ...', tags: ['user-defined', 'raise'] },
  { id: 'MCQ_080', category: 'exception-handling', difficulty: 'Medium', type: 'multiple_choice', question: 'Apa fungsi RAISE_APPLICATION_ERROR?', options: ['Menangkap error', 'Membuat error dengan error number dan pesan custom', 'Menghapus error', 'Logging error ke tabel'], correctAnswer: 1, explanation: 'RAISE_APPLICATION_ERROR(error_number, message) membuat error dengan kode antara -20000 dan -20999 dan pesan custom yang bisa ditangkap oleh caller.', tags: ['raise_application_error'] },
  { id: 'MCQ_081', category: 'exception-handling', difficulty: 'Medium', type: 'multiple_choice', question: 'Range error code untuk RAISE_APPLICATION_ERROR?', options: ['-10000 sampai -10999', '-20000 sampai -20999', '-30000 sampai -30999', '-1 sampai -999'], correctAnswer: 1, explanation: 'RAISE_APPLICATION_ERROR hanya bisa menggunakan error number -20000 sampai -20999. Range ini disediakan khusus untuk user-defined errors.', tags: ['error-code', 'range'] },
  { id: 'MCQ_082', category: 'exception-handling', difficulty: 'Easy', type: 'multiple_choice', question: 'Apa perbedaan SQLCODE dan SQLERRM?', options: ['Sama saja', 'SQLCODE mengembalikan error number, SQLERRM mengembalikan error message', 'SQLERRM mengembalikan number, SQLCODE mengembalikan message', 'SQLCODE untuk SQL, SQLERRM untuk PL/SQL'], correctAnswer: 1, explanation: 'SQLCODE mengembalikan numeric error code (misal -1). SQLERRM mengembalikan error message yang terkait (misal "ORA-00001: unique constraint violated").', tags: ['sqlcode', 'sqlerrm'] },
  { id: 'MCQ_083', category: 'exception-handling', difficulty: 'Medium', type: 'multiple_choice', question: 'Bagaimana cara handle multiple exceptions?', options: ['Hanya bisa handle satu', 'Menggunakan beberapa WHEN clause', 'Menggunakan IF dalam EXCEPTION', 'Hanya WHEN OTHERS yang bisa'], correctAnswer: 1, explanation: 'Bisa menggunakan beberapa WHEN clause: WHEN NO_DATA_FOUND THEN ... WHEN TOO_MANY_ROWS THEN ... WHEN OTHERS THEN ... Setiap clause menangani exception berbeda.', tags: ['multiple', 'when-clause'] },
  { id: 'MCQ_084', category: 'exception-handling', difficulty: 'Easy', type: 'multiple_choice', question: 'Apa fungsi WHEN OTHERS?', options: ['Menangkap exception yang spesifik', 'Menangkap semua exception yang tidak tertangkap handler lainnya', 'Hanya untuk debugging', 'Menangkap error system'], correctAnswer: 1, explanation: 'WHEN OTHERS menangkap semua exception yang tidak di-handle oleh handler spesifik sebelumnya. Harus diletakkan sebagai handler terakhir.', tags: ['when-others', 'catch-all'] },
  { id: 'MCQ_085', category: 'exception-handling', difficulty: 'Hard', type: 'multiple_choice', question: 'Apakah WHEN OTHERS harus di akhir exception handlers?', options: ['Tidak harus', 'Ya, harus menjadi handler terakhir', 'Bisa di awal', 'Bisa di mana saja'], correctAnswer: 1, explanation: 'WHEN OTHERS HARUS menjadi handler terakhir. Jika ditempatkan sebelum handler spesifik lain, Oracle akan error karena handler setelahnya tidak akan pernah tercapai.', tags: ['when-others', 'order'] },
  { id: 'MCQ_086', category: 'exception-handling', difficulty: 'Hard', type: 'multiple_choice', question: 'Bagaimana cara re-raise exception di dalam exception handler?', options: ['THROW;', 'RAISE;', 'RERAISE;', 'Tidak bisa'], correctAnswer: 1, explanation: 'RAISE; tanpa parameter di dalam exception handler akan re-raise exception yang sama ke calling block. Ini berguna untuk logging sebelum meneruskan error.', tags: ['reraise', 'raise'] },
  { id: 'MCQ_087', category: 'exception-handling', difficulty: 'Medium', type: 'multiple_choice', question: 'Apa fungsi PRAGMA EXCEPTION_INIT?', options: ['Membuat exception baru', 'Menghubungkan user-defined exception dengan Oracle error number', 'Inisialisasi exception handler', 'Menonaktifkan exception'], correctAnswer: 1, explanation: 'PRAGMA EXCEPTION_INIT(exception_name, error_number) mengasosiasikan user-defined exception dengan Oracle error number sehingga bisa ditangkap dengan nama.', tags: ['pragma', 'exception_init'] },
  { id: 'MCQ_088', category: 'exception-handling', difficulty: 'Hard', type: 'multiple_choice', question: 'Bagaimana exception propagation bekerja di nested blocks?', options: ['Exception selalu ditangani di block terdalam', 'Jika tidak tertangani, exception naik ke outer block', 'Exception tidak bisa menembus block boundary', 'Semua block menerima exception bersamaan'], correctAnswer: 1, explanation: 'Jika exception tidak di-handle di inner block, ia akan di-propagate ke outer block. Outer block bisa menangkapnya di exception handler-nya. Jika masih tidak tertangkap, propagasi terus ke environment.', tags: ['propagation', 'nested'] },
  { id: 'MCQ_089', category: 'exception-handling', difficulty: 'Easy', type: 'multiple_choice', question: 'Predefined exception apa yang di-raise saat pembagian dengan nol?', options: ['DIVISION_ERROR', 'ZERO_DIVIDE', 'MATH_ERROR', 'DIVIDE_BY_ZERO'], correctAnswer: 1, explanation: 'ZERO_DIVIDE (ORA-01476) di-raise ketika operasi pembagian dengan nol terjadi di PL/SQL block.', tags: ['zero_divide', 'predefined'] },
  { id: 'MCQ_090', category: 'exception-handling', difficulty: 'Medium', type: 'multiple_choice', question: 'Apa yang terjadi pada data DML setelah unhandled exception?', options: ['DML di-commit otomatis', 'DML di-rollback otomatis', 'Tergantung setting AUTOCOMMIT', 'DML tetap pending'], correctAnswer: 1, explanation: 'Ketika unhandled exception terjadi, Oracle melakukan implicit ROLLBACK pada DML yang belum di-commit dalam block tersebut.', tags: ['rollback', 'unhandled', 'dml'] },
  { id: 'MCQ_091', category: 'exception-handling', difficulty: 'Hard', type: 'multiple_choice', question: 'Exception TOO_MANY_ROWS di-raise kapan?', options: ['Ketika INSERT menduplikasi banyak rows', 'Ketika SELECT INTO mengembalikan lebih dari satu baris', 'Ketika cursor fetch berlebihan', 'Ketika tabel sudah penuh'], correctAnswer: 1, explanation: 'TOO_MANY_ROWS (ORA-01422) terjadi ketika SELECT INTO mengembalikan lebih dari satu baris. SELECT INTO mengharapkan tepat satu baris. Solusinya gunakan cursor.', tags: ['too_many_rows', 'select-into'] },
];

export const cat05Code: CodeChallenge[] = [
  {
    id: 'CODE_027',
    category: 'exception-handling',
    difficulty: 'Easy',
    type: 'code_challenge',
    question: 'Handle NO_DATA_FOUND exception. Lakukan SELECT INTO dari tabel employees dengan ID yang tidak ada, lalu tangkap exception-nya.',
    requirements: ['SELECT INTO karyawan dengan employee_id = 9999', 'Tangkap NO_DATA_FOUND', 'Tampilkan pesan "Karyawan tidak ditemukan"'],
    starterCode: 'DECLARE\n  v_name employees.first_name%TYPE;\nBEGIN\n  -- SELECT yang akan gagal\n\nEXCEPTION\n  -- Handler\n\nEND;\n/',
    solution: 'DECLARE\n  v_name employees.first_name%TYPE;\nBEGIN\n  SELECT first_name INTO v_name FROM employees WHERE employee_id = 9999;\n  DBMS_OUTPUT.PUT_LINE(\'Nama: \' || v_name);\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    DBMS_OUTPUT.PUT_LINE(\'Karyawan tidak ditemukan!\');\nEND;\n/',
    hints: ['WHEN NO_DATA_FOUND THEN ...', 'SELECT INTO mengharapkan tepat 1 baris', 'ID 9999 tidak ada sehingga trigger NO_DATA_FOUND'],
    validationRules: { mustContain: ['SELECT', 'INTO', 'EXCEPTION', 'WHEN', 'NO_DATA_FOUND', 'DBMS_OUTPUT.PUT_LINE'], structure: 'anonymous_block' },
    tags: ['no_data_found', 'basic'],
  },
  {
    id: 'CODE_028',
    category: 'exception-handling',
    difficulty: 'Medium',
    type: 'code_challenge',
    question: 'Buat dan raise user-defined exception. Jika salary di bawah 5000, raise exception e_salary_too_low.',
    requirements: ['Deklarasikan e_salary_too_low EXCEPTION', 'Deklarasikan v_salary := 3000', 'IF salary < 5000 THEN RAISE exception', 'Handle exception dengan pesan deskriptif'],
    starterCode: 'DECLARE\n  e_salary_too_low EXCEPTION;\n  v_salary NUMBER := 3000;\nBEGIN\n  -- Cek dan raise\n\nEXCEPTION\n  -- Handle\n\nEND;\n/',
    solution: 'DECLARE\n  e_salary_too_low EXCEPTION;\n  v_salary NUMBER := 3000;\nBEGIN\n  IF v_salary < 5000 THEN\n    RAISE e_salary_too_low;\n  END IF;\n  DBMS_OUTPUT.PUT_LINE(\'Salary OK: \' || v_salary);\nEXCEPTION\n  WHEN e_salary_too_low THEN\n    DBMS_OUTPUT.PUT_LINE(\'Error: Salary \' || v_salary || \' terlalu rendah (minimum 5000)\');\nEND;\n/',
    hints: ['Deklarasi: exc_name EXCEPTION;', 'Raise: RAISE exc_name;', 'Handle: WHEN exc_name THEN ...'],
    validationRules: { mustContain: ['EXCEPTION', 'RAISE', 'WHEN', 'IF', 'THEN', 'DBMS_OUTPUT.PUT_LINE'], mustDeclare: ['e_salary_too_low'], structure: 'anonymous_block' },
    tags: ['user-defined', 'raise'],
  },
  {
    id: 'CODE_029',
    category: 'exception-handling',
    difficulty: 'Medium',
    type: 'code_challenge',
    question: 'Gunakan RAISE_APPLICATION_ERROR untuk membuat custom error dengan kode -20001 saat usia karyawan di bawah 17 tahun.',
    requirements: ['Deklarasikan v_age NUMBER := 15', 'IF age < 17, gunakan RAISE_APPLICATION_ERROR(-20001, message)', 'Handle error di exception section'],
    starterCode: 'DECLARE\n  v_age NUMBER := 15;\nBEGIN\n  -- Validasi usia\n\nEXCEPTION\n  WHEN OTHERS THEN\n    DBMS_OUTPUT.PUT_LINE(\'Error: \' || SQLERRM);\nEND;\n/',
    solution: 'DECLARE\n  v_age NUMBER := 15;\nBEGIN\n  IF v_age < 17 THEN\n    RAISE_APPLICATION_ERROR(-20001, \'Usia minimum karyawan adalah 17 tahun. Usia: \' || v_age);\n  END IF;\n  DBMS_OUTPUT.PUT_LINE(\'Usia valid: \' || v_age);\nEXCEPTION\n  WHEN OTHERS THEN\n    DBMS_OUTPUT.PUT_LINE(\'Error Code: \' || SQLCODE);\n    DBMS_OUTPUT.PUT_LINE(\'Error Message: \' || SQLERRM);\nEND;\n/',
    hints: ['RAISE_APPLICATION_ERROR(code, message)', 'Error code harus antara -20000 dan -20999', 'SQLCODE dan SQLERRM memberikan detail error'],
    validationRules: { mustContain: ['RAISE_APPLICATION_ERROR', 'EXCEPTION', 'WHEN', 'SQLERRM'], mustDeclare: ['v_age'], structure: 'anonymous_block' },
    tags: ['raise_application_error', 'validation'],
  },
  {
    id: 'CODE_030',
    category: 'exception-handling',
    difficulty: 'Hard',
    type: 'code_challenge',
    question: 'Demonstrasikan exception propagation dari inner block ke outer block. Inner block raise exception yang ditangkap outer block.',
    requirements: ['Outer block dengan exception handler', 'Inner block yang raise exception', 'Inner block TIDAK menangani exception', 'Outer block menangkap dan menampilkan pesan'],
    starterCode: 'BEGIN\n  -- Outer block\n  DBMS_OUTPUT.PUT_LINE(\'Outer: Sebelum inner\');\n  \n  BEGIN\n    -- Inner block yang raise error\n    \n  END;\n  \n  DBMS_OUTPUT.PUT_LINE(\'Outer: Setelah inner\');\nEXCEPTION\n  -- Outer handler\n\nEND;\n/',
    solution: 'BEGIN\n  DBMS_OUTPUT.PUT_LINE(\'Outer: Sebelum inner\');\n  \n  BEGIN\n    DBMS_OUTPUT.PUT_LINE(\'Inner: Sebelum error\');\n    RAISE ZERO_DIVIDE;\n    DBMS_OUTPUT.PUT_LINE(\'Inner: Setelah error (tidak pernah tercapai)\');\n  END;\n  \n  DBMS_OUTPUT.PUT_LINE(\'Outer: Setelah inner (tidak pernah tercapai)\');\nEXCEPTION\n  WHEN ZERO_DIVIDE THEN\n    DBMS_OUTPUT.PUT_LINE(\'Outer: Exception ditangkap! Error dari inner block.\');\nEND;\n/',
    hints: ['RAISE nama_exception; tanpa kondisi langsung raise', 'Exception yang tidak ditangkap inner block naik ke outer', 'Kode setelah inner block yang error tidak dieksekusi'],
    validationRules: { mustContain: ['BEGIN', 'END', 'RAISE', 'EXCEPTION', 'WHEN', 'DBMS_OUTPUT.PUT_LINE'], structure: 'anonymous_block' },
    tags: ['propagation', 'nested-blocks'],
  },
];
