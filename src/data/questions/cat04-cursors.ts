import { MCQuestion, CodeChallenge } from '@/types';

export const cat04MCQ: MCQuestion[] = [
  { id: 'MCQ_059', category: 'cursors', difficulty: 'Easy', type: 'multiple_choice', question: 'Apa perbedaan implicit dan explicit cursor?', options: ['Implicit cursor dibuat otomatis oleh Oracle untuk DML, explicit dibuat manual', 'Explicit cursor lebih cepat', 'Implicit cursor untuk SELECT, explicit untuk DML', 'Tidak ada perbedaan'], correctAnswer: 0, explanation: 'Implicit cursor dibuat otomatis oleh Oracle untuk setiap DML statement (INSERT, UPDATE, DELETE) dan SELECT INTO. Explicit cursor dideklarasikan dan dikontrol manual oleh programmer.', tags: ['implicit', 'explicit', 'basic'] },
  { id: 'MCQ_060', category: 'cursors', difficulty: 'Easy', type: 'multiple_choice', question: 'Attribute mana yang menunjukkan berapa baris yang di-fetch?', options: ['%FOUND', '%NOTFOUND', '%ROWCOUNT', '%ISOPEN'], correctAnswer: 2, explanation: '%ROWCOUNT mengembalikan jumlah baris yang telah di-fetch oleh cursor. Untuk implicit cursor, SQL%ROWCOUNT menunjukkan jumlah baris yang terpengaruh oleh DML terakhir.', tags: ['%rowcount', 'attribute'] },
  { id: 'MCQ_061', category: 'cursors', difficulty: 'Medium', type: 'multiple_choice', question: 'Apa yang terjadi jika lupa menutup (CLOSE) explicit cursor?', options: ['Tidak ada efek', 'Error compile-time', 'Cursor tetap terbuka dan menggunakan resource sampai session berakhir', 'Oracle otomatis menutupnya'], correctAnswer: 2, explanation: 'Cursor yang tidak di-CLOSE tetap terbuka dan mengonsumsi memory resource. Jika terlalu banyak cursor terbuka, bisa menyebabkan ORA-01000: maximum open cursors exceeded.', tags: ['close', 'resource', 'best-practice'] },
  { id: 'MCQ_062', category: 'cursors', difficulty: 'Medium', type: 'multiple_choice', question: 'Apa keuntungan cursor FOR loop dibanding fetch manual?', options: ['Lebih cepat', 'Otomatis OPEN, FETCH, CLOSE', 'Bisa di-nest', 'Mendukung parameter'], correctAnswer: 1, explanation: 'Cursor FOR loop secara otomatis melakukan OPEN, FETCH, dan CLOSE. Ini mengurangi kode boilerplate dan mengurangi risiko cursor yang lupa ditutup.', tags: ['cursor-for-loop', 'advantage'] },
  { id: 'MCQ_063', category: 'cursors', difficulty: 'Medium', type: 'multiple_choice', question: 'Bagaimana cara passing parameter ke cursor?', options: ['Tidak bisa', 'CURSOR c(p_id NUMBER) IS SELECT ...', 'CURSOR c PARAM(p_id) IS SELECT ...', 'CURSOR c IS SELECT ... WHERE id = @p_id'], correctAnswer: 1, explanation: 'Cursor parameter dideklarasikan setelah nama cursor: CURSOR c(p_id NUMBER) IS SELECT * FROM tbl WHERE id = p_id; Saat OPEN, pass nilai: OPEN c(100);', tags: ['cursor-parameter', 'syntax'] },
  { id: 'MCQ_064', category: 'cursors', difficulty: 'Hard', type: 'multiple_choice', question: 'Apa fungsi FOR UPDATE clause pada cursor?', options: ['Mempercepat update', 'Mengunci (lock) rows yang di-select agar tidak diubah proses lain', 'Menandai cursor untuk update saja', 'Mengizinkan update di dalam loop'], correctAnswer: 1, explanation: 'FOR UPDATE pada cursor meng-lock baris yang di-select sampai COMMIT atau ROLLBACK. Ini mencegah proses lain mengubah baris tersebut selama kita memprosesnya (pessimistic locking).', tags: ['for-update', 'locking'] },
  { id: 'MCQ_065', category: 'cursors', difficulty: 'Hard', type: 'multiple_choice', question: 'Kapan menggunakan REF CURSOR?', options: ['Selalu, karena lebih baik dari explicit cursor', 'Ketika query cursor ditentukan saat runtime (dynamic)', 'Hanya di packages', 'Hanya untuk SELECT INTO'], correctAnswer: 1, explanation: 'REF CURSOR (cursor variable) digunakan ketika query belum diketahui saat compile-time dan ditentukan saat runtime. Ini memungkinkan cursor yang lebih fleksibel dan bisa di-pass sebagai parameter.', tags: ['ref-cursor', 'dynamic'] },
  { id: 'MCQ_066', category: 'cursors', difficulty: 'Easy', type: 'multiple_choice', question: 'Apa urutan operasi untuk explicit cursor?', options: ['FETCH, OPEN, CLOSE', 'OPEN, FETCH, CLOSE', 'DECLARE, OPEN, CLOSE', 'OPEN, CLOSE, FETCH'], correctAnswer: 1, explanation: 'Urutan explicit cursor: 1) DECLARE (di DECLARE section), 2) OPEN (mengeksekusi query), 3) FETCH (mengambil data baris per baris), 4) CLOSE (melepas resource).', tags: ['lifecycle', 'open-fetch-close'] },
  { id: 'MCQ_067', category: 'cursors', difficulty: 'Medium', type: 'multiple_choice', question: 'Apa nilai %ROWCOUNT sebelum fetch pertama?', options: ['NULL', '0', '1', 'Error'], correctAnswer: 1, explanation: 'Sebelum fetch pertama, %ROWCOUNT bernilai 0. Setiap kali FETCH berhasil, %ROWCOUNT bertambah 1.', tags: ['%rowcount', 'initial-value'] },
  { id: 'MCQ_068', category: 'cursors', difficulty: 'Medium', type: 'multiple_choice', question: 'Bagaimana cara update row yang sedang di-fetch oleh cursor?', options: ['UPDATE tbl SET ... WHERE id = v_id;', 'UPDATE tbl SET ... WHERE CURRENT OF cursor_name;', 'cursor_name.UPDATE(...)', 'Tidak bisa update dari cursor'], correctAnswer: 1, explanation: 'WHERE CURRENT OF digunakan bersama cursor FOR UPDATE untuk update baris yang sedang di-fetch: UPDATE tbl SET col = val WHERE CURRENT OF cursor_name;', tags: ['where-current-of', 'update'] },
  { id: 'MCQ_069', category: 'cursors', difficulty: 'Easy', type: 'multiple_choice', question: 'Apa perbedaan %FOUND dan %NOTFOUND?', options: ['Sama saja', '%FOUND TRUE jika fetch berhasil, %NOTFOUND TRUE jika fetch gagal', '%FOUND untuk DML, %NOTFOUND untuk SELECT', '%FOUND cek cursor terbuka, %NOTFOUND cek cursor tertutup'], correctAnswer: 1, explanation: '%FOUND bernilai TRUE jika FETCH terakhir berhasil mengambil data. %NOTFOUND bernilai TRUE jika FETCH terakhir tidak menemukan baris (end of result set). Keduanya saling berlawanan.', tags: ['%found', '%notfound', 'comparison'] },
  { id: 'MCQ_070', category: 'cursors', difficulty: 'Hard', type: 'multiple_choice', question: 'Apa yang dimaksud cursor dengan parameterized subquery?', options: ['Cursor yang menerima query sebagai parameter', 'Cursor yang parameter-nya digunakan di WHERE clause', 'Cursor yang hanya bisa dipakai sekali', 'Cursor yang otomatis di-close'], correctAnswer: 1, explanation: 'Parameterized cursor adalah cursor yang menerima parameter formal, biasanya digunakan di WHERE clause query-nya. Ini membuat cursor reusable dengan nilai filter yang berbeda setiap kali dibuka.', tags: ['parameterized', 'cursor'] },
  { id: 'MCQ_071', category: 'cursors', difficulty: 'Medium', type: 'multiple_choice', question: 'Syntax cursor FOR loop yang BENAR adalah?', options: ['FOR rec IN cursor_name LOOP ... END LOOP;', 'FOREACH rec IN cursor_name LOOP ... END LOOP;', 'FOR rec FROM cursor_name LOOP ... END LOOP;', 'CURSOR LOOP rec cursor_name ... END LOOP;'], correctAnswer: 0, explanation: 'Syntax cursor FOR loop: FOR record_variable IN cursor_name LOOP ... END LOOP; Record variable otomatis dideklarasikan dan tidak perlu OPEN/CLOSE.', tags: ['cursor-for-loop', 'syntax'] },
  { id: 'MCQ_072', category: 'cursors', difficulty: 'Hard', type: 'multiple_choice', question: 'Apa tipe data SYS_REFCURSOR?', options: ['Strong REF CURSOR yang sudah di-define return type-nya', 'Weak REF CURSOR bawaan Oracle yang bisa digunakan tanpa mendefinisikan TYPE sendiri', 'Cursor khusus untuk system tables', 'Cursor yang tidak bisa ditutup'], correctAnswer: 1, explanation: 'SYS_REFCURSOR adalah weak REF CURSOR predefined oleh Oracle. Tidak perlu membuat TYPE sendiri. Bisa diasosiasikan dengan query apapun saat runtime (dynamic).', tags: ['sys_refcursor', 'weak', 'predefined'] },
  { id: 'MCQ_073', category: 'cursors', difficulty: 'Easy', type: 'multiple_choice', question: 'Apa yang terjadi jika FETCH dilakukan pada cursor yang sudah ditutup?', options: ['Mengembalikan NULL', 'Mengembalikan baris terakhir', 'Error ORA-01001: invalid cursor', 'Cursor otomatis dibuka kembali'], correctAnswer: 2, explanation: 'FETCH dari cursor yang sudah di-CLOSE akan menghasilkan error INVALID_CURSOR (ORA-01001). Cursor harus di-OPEN kembali sebelum bisa di-FETCH.', tags: ['invalid-cursor', 'error', 'fetch'] },
  { id: 'MCQ_074', category: 'cursors', difficulty: 'Medium', type: 'multiple_choice', question: 'Apa keuntungan menggunakan BULK COLLECT dengan cursor?', options: ['Kode lebih pendek', 'Mengurangi context switch antara PL/SQL dan SQL engine', 'Bisa fetch dari multiple tables', 'Membuat cursor lebih stabil'], correctAnswer: 1, explanation: 'BULK COLLECT mengurangi context switch dengan fetch banyak baris sekaligus ke collection, bukan satu per satu. Ini meningkatkan performa signifikan untuk dataset besar.', tags: ['bulk-collect', 'performance'] },
  { id: 'MCQ_075', category: 'cursors', difficulty: 'Hard', type: 'multiple_choice', question: 'Apa yang dimaksud "cursor sharing" di Oracle?', options: ['Dua session menggunakan cursor yang sama', 'Oracle menggunakan kembali execution plan cursor yang serupa', 'Cursor yang bisa diakses dari beberapa packages', 'Teknik berbagi data antar cursor'], correctAnswer: 1, explanation: 'Cursor sharing adalah fitur Oracle yang mengizinkan SQL statements yang mirip (berbeda hanya di literal values) untuk berbagi cursor dan execution plan. Diatur oleh parameter CURSOR_SHARING.', tags: ['cursor-sharing', 'optimization'] },
  { id: 'MCQ_076', category: 'cursors', difficulty: 'Medium', type: 'multiple_choice', question: 'Apa perbedaan strong REF CURSOR dan weak REF CURSOR?', options: ['Strong lebih cepat', 'Strong memiliki return type yang spesifik, weak bisa untuk query apapun', 'Weak tidak bisa ditutup', 'Tidak ada perbedaan'], correctAnswer: 1, explanation: 'Strong REF CURSOR memiliki return type yang spesifik (misal: RETURN employees%ROWTYPE). Weak REF CURSOR (termasuk SYS_REFCURSOR) tidak punya return type spesifik dan bisa diasosiasikan dengan query apapun.', tags: ['strong', 'weak', 'ref-cursor'] },
];

export const cat04Code: CodeChallenge[] = [
  {
    id: 'CODE_023',
    category: 'cursors',
    difficulty: 'Easy',
    type: 'code_challenge',
    question: 'Buatlah explicit cursor untuk select data dari tabel employees (employee_id, first_name, salary). Gunakan OPEN-FETCH-CLOSE untuk mengambil dan menampilkan data.',
    requirements: ['Deklarasikan cursor untuk SELECT employee_id, first_name, salary FROM employees', 'Deklarasikan variabel untuk menampung data', 'OPEN cursor, FETCH minimal 3 baris, CLOSE cursor'],
    starterCode: 'DECLARE\n  CURSOR c_emp IS\n    SELECT employee_id, first_name, salary FROM employees WHERE ROWNUM <= 3;\n  v_id employees.employee_id%TYPE;\n  v_name employees.first_name%TYPE;\n  v_sal employees.salary%TYPE;\nBEGIN\n  -- OPEN, FETCH, CLOSE\n\nEND;\n/',
    solution: 'DECLARE\n  CURSOR c_emp IS\n    SELECT employee_id, first_name, salary FROM employees WHERE ROWNUM <= 3;\n  v_id employees.employee_id%TYPE;\n  v_name employees.first_name%TYPE;\n  v_sal employees.salary%TYPE;\nBEGIN\n  OPEN c_emp;\n  LOOP\n    FETCH c_emp INTO v_id, v_name, v_sal;\n    EXIT WHEN c_emp%NOTFOUND;\n    DBMS_OUTPUT.PUT_LINE(v_id || \' - \' || v_name || \': \' || v_sal);\n  END LOOP;\n  CLOSE c_emp;\nEND;\n/',
    hints: ['OPEN cursor_name; untuk membuka cursor', 'FETCH cursor_name INTO variabel1, variabel2, ...;', 'Gunakan %NOTFOUND untuk cek apakah masih ada data'],
    validationRules: { mustContain: ['CURSOR', 'OPEN', 'FETCH', 'CLOSE', 'LOOP', 'EXIT WHEN', '%NOTFOUND'], structure: 'anonymous_block' },
    tags: ['explicit-cursor', 'open-fetch-close'],
  },
  {
    id: 'CODE_024',
    category: 'cursors',
    difficulty: 'Easy',
    type: 'code_challenge',
    question: 'Gunakan cursor FOR loop untuk iterate data karyawan dan tampilkan nama serta gajinya.',
    requirements: ['Deklarasikan cursor c_emp', 'Gunakan FOR rec IN c_emp LOOP', 'Tampilkan rec.first_name dan rec.salary'],
    starterCode: 'DECLARE\n  CURSOR c_emp IS\n    SELECT first_name, salary FROM employees WHERE ROWNUM <= 5;\nBEGIN\n  -- Cursor FOR loop\n\nEND;\n/',
    solution: 'DECLARE\n  CURSOR c_emp IS\n    SELECT first_name, salary FROM employees WHERE ROWNUM <= 5;\nBEGIN\n  FOR rec IN c_emp LOOP\n    DBMS_OUTPUT.PUT_LINE(rec.first_name || \': Rp \' || rec.salary);\n  END LOOP;\nEND;\n/',
    hints: ['FOR rec IN cursor_name LOOP ...', 'Akses kolom: rec.nama_kolom', 'Tidak perlu OPEN/CLOSE, otomatis!'],
    validationRules: { mustContain: ['CURSOR', 'FOR', 'IN', 'LOOP', 'END LOOP', 'DBMS_OUTPUT.PUT_LINE'], structure: 'anonymous_block' },
    tags: ['cursor-for-loop', 'basic'],
  },
  {
    id: 'CODE_025',
    category: 'cursors',
    difficulty: 'Medium',
    type: 'code_challenge',
    question: 'Buatlah cursor dengan parameter yang menerima department_id, lalu tampilkan karyawan di department tersebut.',
    requirements: ['Cursor dengan parameter p_dept_id NUMBER', 'SELECT karyawan berdasarkan department_id', 'Gunakan cursor FOR loop', 'Panggil untuk department 10 dan 20'],
    starterCode: 'DECLARE\n  -- Cursor dengan parameter\n\nBEGIN\n  -- Panggil untuk dept 10\n\n  -- Panggil untuk dept 20\n\nEND;\n/',
    solution: 'DECLARE\n  CURSOR c_emp(p_dept_id NUMBER) IS\n    SELECT first_name, salary FROM employees WHERE department_id = p_dept_id;\nBEGIN\n  DBMS_OUTPUT.PUT_LINE(\'--- Department 10 ---\');\n  FOR rec IN c_emp(10) LOOP\n    DBMS_OUTPUT.PUT_LINE(rec.first_name || \': \' || rec.salary);\n  END LOOP;\n  DBMS_OUTPUT.PUT_LINE(\'--- Department 20 ---\');\n  FOR rec IN c_emp(20) LOOP\n    DBMS_OUTPUT.PUT_LINE(rec.first_name || \': \' || rec.salary);\n  END LOOP;\nEND;\n/',
    hints: ['CURSOR c(param TIPE) IS SELECT ...', 'FOR rec IN c(nilai) LOOP', 'Cursor bisa dibuka berkali-kali dengan parameter berbeda'],
    validationRules: { mustContain: ['CURSOR', 'FOR', 'LOOP', 'DBMS_OUTPUT.PUT_LINE'], structure: 'anonymous_block' },
    tags: ['cursor-parameter', 'reusable'],
  },
  {
    id: 'CODE_026',
    category: 'cursors',
    difficulty: 'Medium',
    type: 'code_challenge',
    question: 'Gunakan cursor attributes (%FOUND, %NOTFOUND, %ROWCOUNT) dalam loop untuk menampilkan jumlah baris yang berhasil di-fetch.',
    requirements: ['Buat cursor untuk select employees', 'Dalam loop, cetak %ROWCOUNT setelah setiap fetch', 'Di akhir, tampilkan total rows fetched'],
    starterCode: 'DECLARE\n  CURSOR c_emp IS SELECT first_name FROM employees WHERE ROWNUM <= 5;\n  v_name employees.first_name%TYPE;\nBEGIN\n  OPEN c_emp;\n  -- Fetch dengan attributes\n\n  CLOSE c_emp;\nEND;\n/',
    solution: 'DECLARE\n  CURSOR c_emp IS SELECT first_name FROM employees WHERE ROWNUM <= 5;\n  v_name employees.first_name%TYPE;\nBEGIN\n  OPEN c_emp;\n  LOOP\n    FETCH c_emp INTO v_name;\n    EXIT WHEN c_emp%NOTFOUND;\n    DBMS_OUTPUT.PUT_LINE(\'Row \' || c_emp%ROWCOUNT || \': \' || v_name);\n  END LOOP;\n  DBMS_OUTPUT.PUT_LINE(\'Total rows: \' || c_emp%ROWCOUNT);\n  CLOSE c_emp;\nEND;\n/',
    hints: ['%ROWCOUNT mengembalikan jumlah baris yang sudah di-fetch', '%NOTFOUND TRUE jika fetch tidak menemukan data', 'Akses attribute: cursor_name%ATTRIBUTE'],
    validationRules: { mustContain: ['CURSOR', 'OPEN', 'FETCH', 'CLOSE', '%ROWCOUNT', '%NOTFOUND'], structure: 'anonymous_block' },
    tags: ['cursor-attributes', '%rowcount'],
  },
];
