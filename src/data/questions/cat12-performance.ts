import { MCQuestion, CodeChallenge } from '@/types';

export const cat12MCQ: MCQuestion[] = [
  { id: 'MCQ_141', category: 'performance-best-practices', difficulty: 'Medium', type: 'multiple_choice', question: 'Apa keuntungan menggunakan bind variables?', options: ['Kode lebih pendek', 'Mengurangi hard parsing, meningkatkan shared pool efficiency dan performa', 'Membuat kode immutable', 'Hanya untuk stored procedures'], correctAnswer: 1, explanation: 'Bind variables memungkinkan Oracle reuse execution plan (soft parse vs hard parse), mengurangi beban CPU dan meningkatkan shared pool efficiency. Ini best practice fundamental.', tags: ['bind-variables', 'performance'] },
  { id: 'MCQ_142', category: 'performance-best-practices', difficulty: 'Medium', type: 'multiple_choice', question: 'Kapan menggunakan BULK COLLECT?', options: ['Selalu untuk semua query', 'Ketika perlu fetch banyak baris sekaligus untuk mengurangi context switches', 'Hanya untuk tabel besar (>1M rows)', 'Hanya dengan explicit cursor'], correctAnswer: 1, explanation: 'BULK COLLECT optimal saat fetch banyak baris. Mengurangi context switch antara PL/SQL dan SQL engine. Gunakan LIMIT clause untuk mengontrol memori: FETCH c BULK COLLECT INTO coll LIMIT 1000;', tags: ['bulk-collect', 'when-to-use'] },
  { id: 'MCQ_143', category: 'performance-best-practices', difficulty: 'Hard', type: 'multiple_choice', question: 'Apa fungsi NOCOPY hint?', options: ['Menghindari copy data', 'Mem-pass OUT/IN OUT parameter by reference alih-alih by value untuk performa', 'Mencegah duplikasi data', 'Menghapus copy table'], correctAnswer: 1, explanation: 'NOCOPY hint membuat OUT dan IN OUT parameter di-pass by reference (bukan by value), menghindari copy data besar. Contoh: PROCEDURE p(x IN OUT NOCOPY CLOB). Meningkatkan performa untuk parameter berukuran besar.', tags: ['nocopy', 'hint', 'performance'] },
  { id: 'MCQ_144', category: 'performance-best-practices', difficulty: 'Hard', type: 'multiple_choice', question: 'Apa itu RESULT_CACHE?', options: ['Cache semua result set', 'Menyimpan hasil function di server-level cache sehingga tidak perlu re-execute', 'Menyimpan procedure result', 'Buffer untuk SELECT'], correctAnswer: 1, explanation: 'RESULT_CACHE pragma pada function menyimpan hasil di server-level cache. Panggilan berikutnya dengan parameter sama langsung return dari cache tanpa re-execute function body.', tags: ['result-cache', 'optimization'] },
  { id: 'MCQ_145', category: 'performance-best-practices', difficulty: 'Medium', type: 'multiple_choice', question: 'Best practice untuk exception handling?', options: ['Selalu gunakan WHEN OTHERS tanpa RAISE', 'Handle exception spesifik, log di WHEN OTHERS, lalu RAISE', 'Abaikan semua exception', 'Hanya gunakan predefined exceptions'], correctAnswer: 1, explanation: 'Best practice: 1) Handle exception spesifik terlebih dulu, 2) Di WHEN OTHERS, log error (SQLCODE, SQLERRM) lalu RAISE untuk propagate, 3) Jangan "menelan" exception tanpa logging.', tags: ['exception', 'best-practice'] },
  { id: 'MCQ_146', category: 'performance-best-practices', difficulty: 'Easy', type: 'multiple_choice', question: 'Bagaimana menghindari implicit conversion?', options: ['Selalu gunakan VARCHAR2', 'Gunakan tipe data yang sesuai dan explicit conversion (TO_NUMBER, TO_CHAR, TO_DATE)', 'Tidak perlu dikhawatirkan', 'Gunakan CAST untuk semua'], correctAnswer: 1, explanation: 'Implicit conversion bisa menyebabkan bug tersembunyi dan mengurangi performa. Gunakan explicit conversion: TO_NUMBER, TO_CHAR, TO_DATE untuk kejelasan dan menghindari error.', tags: ['implicit-conversion', 'explicit'] },
  { id: 'MCQ_147', category: 'performance-best-practices', difficulty: 'Medium', type: 'multiple_choice', question: 'Kapan menggunakan explicit cursor vs implicit cursor?', options: ['Selalu explicit', 'Selalu implicit', 'Implicit untuk single-row, explicit untuk multi-row processing', 'Tidak ada perbedaan performa'], correctAnswer: 2, explanation: 'Implicit cursor (SELECT INTO) cocok untuk mengambil satu baris. Explicit cursor lebih tepat untuk proses multi-row (iterasi). Cursor FOR loop lebih disukai untuk readability.', tags: ['cursor', 'choice'] },
  { id: 'MCQ_148', category: 'performance-best-practices', difficulty: 'Hard', type: 'multiple_choice', question: 'Apa keuntungan PLS_INTEGER dibanding NUMBER untuk variabel loop counter?', options: ['Tidak ada', 'PLS_INTEGER menggunakan machine arithmetic (lebih cepat)', 'NUMBER lebih akurat', 'PLS_INTEGER bisa menampung angka lebih besar'], correctAnswer: 1, explanation: 'PLS_INTEGER menggunakan native machine arithmetic yang lebih cepat dari library arithmetic yang dipakai NUMBER. Untuk loop counters dan integer operations, PLS_INTEGER lebih efisien.', tags: ['pls_integer', 'number', 'performance'] },
  { id: 'MCQ_149', category: 'performance-best-practices', difficulty: 'Medium', type: 'multiple_choice', question: 'Best practice naming convention di PL/SQL?', options: ['Tidak penting', 'Prefix: v_ variabel, c_ constant, p_ parameter, e_ exception, t_ type', 'Semua huruf besar', 'Tanpa prefix'], correctAnswer: 1, explanation: 'Naming convention dengan prefix membantu readability: v_ untuk local variables, c_ untuk constants, p_ untuk parameters, g_ untuk global, e_ untuk exceptions, t_ untuk types.', tags: ['naming', 'convention'] },
  { id: 'MCQ_150', category: 'performance-best-practices', difficulty: 'Hard', type: 'multiple_choice', question: 'Apa keuntungan native compilation di PL/SQL?', options: ['Kode berjalan di browser', 'PL/SQL dikompilasi ke machine code native, mengeksekusi lebih cepat', 'Tidak perlu Oracle DB', 'Kode bisa dipakai di Java'], correctAnswer: 1, explanation: 'PLSQL_CODE_TYPE = NATIVE mengompilasi PL/SQL ke machine code native alih-alih bytecode, memberikan peningkatan performa untuk code-intensive operations (bukan SQL-heavy).', tags: ['native', 'compilation', 'performance'] },
];

export const cat12Code: CodeChallenge[] = [
  {
    id: 'CODE_039',
    category: 'performance-best-practices',
    difficulty: 'Medium',
    type: 'code_challenge',
    question: 'Refaktor kode yang fetch satu-per-satu menjadi menggunakan BULK COLLECT. Fetch semua nama karyawan sekaligus ke collection.',
    requirements: ['TYPE t_names IS TABLE OF employees.first_name%TYPE', 'SELECT first_name BULK COLLECT INTO v_names FROM employees', 'Loop collection untuk menampilkan', 'Gunakan LIMIT jika perlu'],
    starterCode: 'DECLARE\n  TYPE t_names IS TABLE OF VARCHAR2(50);\n  v_names t_names;\nBEGIN\n  -- BULK COLLECT\n\n  -- Tampilkan\n\nEND;\n/',
    solution: 'DECLARE\n  TYPE t_names IS TABLE OF VARCHAR2(50);\n  v_names t_names;\nBEGIN\n  SELECT first_name BULK COLLECT INTO v_names\n  FROM employees\n  WHERE ROWNUM <= 20;\n  \n  FOR i IN 1..v_names.COUNT LOOP\n    DBMS_OUTPUT.PUT_LINE(i || \'. \' || v_names(i));\n  END LOOP;\n  \n  DBMS_OUTPUT.PUT_LINE(\'Total: \' || v_names.COUNT || \' karyawan\');\nEND;\n/',
    hints: ['SELECT ... BULK COLLECT INTO collection FROM table', '.COUNT mengembalikan jumlah elemen', 'Iterate: FOR i IN 1..coll.COUNT LOOP'],
    validationRules: { mustContain: ['BULK COLLECT', 'INTO', 'SELECT', 'LOOP', 'DBMS_OUTPUT.PUT_LINE'], structure: 'anonymous_block' },
    tags: ['bulk-collect', 'refactor', 'performance'],
  },
];
